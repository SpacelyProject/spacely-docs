# Autogeneration Tools for Spacely-Caribou Firmware

The Spacely-Caribou architecture requires firmware blocks to be connected to a shared AXI bus which is used to read/write data to registers in those blocks. Autogeneration tools are provided to generate this AXI interface for any new firmware block. Following this process significantly reduces the effort involved in developing new firmware blocks, and eliminates many common errors. The full process is summarized by the graphic below. 

<p align="center">
<img src="https://github.com/SpacelyProject/spacely-docs/blob/main/figures/spacely-caribou/FirmwareAutogenerationDiagram.PNG" width="700">
</p>


## fw_description Format

When an engineer writes a new firmware block (myModule.sv), they must write an accompanying myModule.fw_description file. This file is an extremely simple, machine-readable description of the I/O ports, AXI registers, and parameters of the block. 

Each parameter is described by a single line with the format:

```
PARAMETER {name} {default_value}
```

Each port (a signal that will be exposed at the top level of the block to connect to other firmware blocks or I/O pins) is described by a single line with the format:

```
PORT {name} {width} {direction}
```

Where *direction* is an integer (0=input, 1=output)

Each AXI-addressable register is described by a single line with the format:

```
REGISTER {name} {width} {type}
```

Where *type* is an integer (0=read/write, 1=read-only, 2=trigger/pulse). A trigger/pulse register delivers a pulse which is a single AXI clock cycle wide to the firmware block whenever any value is written to it. 


For an exemplary fw_description file, see the [Arbitrary Pattern Generator block](<https://github.com/SpacelyProject/spacely-caribou-common-blocks/blob/main/Arbitrary_Wave_Generator/APG.fw_description>)

## Autogenerating Firmware Wrappers from fw_description

To generate firmware wrappers from a fw_description file, run Spacely (it does not matter which ASIC Spacely is targeting) and type **gen_fw()** in the main Spacely shell. You will be prompted to give a name to your block ("myModule") and to select your myModule.fw_description file. Three files will be generated:

- **myModule_interface.sv** -- A SystemVerilog file that implements the AXI interface to your block. 
- **myModule_top.v** -- A Verilog wrapper to allow your block to be instantiated in a Vivado block diagram.
- **README.md** -- A partially-filled README file in the format specified by the spacely-caribou-common-blocks repository. This file will contain tables which describe all of the ports, registers, and parameters from the fw_description file, but it is the engineer's responsibility to fill in the details of these tables based on their knowledge of the design. 



## Autogenerating a Memory Map from mem_map.txt

All of the firmware blocks in a firmware image are placed inside a memory address space. Each firmware block has a base address, and each register inside that block has an offset from that base address. In order for the Peary server to successfully locate these registers, we need to provide it a map of the locations of these registers, which lives inside *SpacelyCaribouBasicDefaults.hpp*. For simplicity, we will autogenerate this memory map from a simple text file, *mem_map.txt*.

The format of the *mem_map.txt* file is described in the next section. Once this file is written, run Spacely (it does not matter which ASIC Spacely is targeting) and type **gen_mem_map()** in the main Spacely shell. You will be prompted to open your *mem_map.txt*, and then Spacely will print a C++ memory map which may be copied directly into *SpacelyCaribouBasicDefaults.hpp*.

## mem_map.txt Format

 The format of this file is as follows:

The base address of each block is specified by a line starting with "\*BASE". This base address is effective until the next "\*BASE" line. Base addresses for each block are set in the Vivado Address Editor. **To be compliant with Spacely-Caribou, base addresses should be in the range 0x4_0000_0000 to 0x4_FFFF_FFFF.**


```
*BASE (IP Base Address)
```

After the base address is specified, each register is defined using a line with the format below. 

**NOTE:** If you use the auto-generation process from a fw_description file as described above, you do **NOT** need to write these lines by hand. The last section of the autogenerated README.md file contains a memory map for your block, which can be copy-and-pasted into your mem_map.txt. In this case, you only need to do two things for each block:

1. Update the base address from Vivado as described above.
2. If you are using multiple instances of a block, update the register names with an instance-specific prefix to prevent having multiple registers in your memory map with the same name.

Register format:

```
(name),(address_offset),(bitmask),(readable?),(writeable?)
```

Where:
- Name = String name, which will be used to call the register in software. 
- address_offset = Offset in bytes relative to the base address.
- bitmask = Which bits of the 32b AXI word correspond to this register. For a 32-bit register: 0xFFFFFFFF. For a 1-bit register it might be 0x1 or 0x2 or 0x4.
- readable? = True if readable, else False
- writeable? = True if writeable, else False


